using Unity.Burst;
using Unity.Collections;
using Unity.Entities;
using UnityEngine.Profiling;

namespace thelebaron.damage
{
    public class HealthSystem : SystemBase
    {
        private EndSimulationEntityCommandBufferSystem endSimulationEntityCommandBufferSystem;
        private EntityQuery                            damageEventsQuery;
        private EntityQuery healthQuery;
        //private EntityQuery                            historyQuery;

        protected override void OnCreate()
        {
            endSimulationEntityCommandBufferSystem            = World.GetOrCreateSystem<EndSimulationEntityCommandBufferSystem>();
            damageEventsQuery = GetEntityQuery(ComponentType.ReadOnly<DamageEvent>());
            healthQuery = GetEntityQuery(ComponentType.ReadWrite<Health>(), ComponentType.ReadWrite<HealthBuffer>(), ComponentType.Exclude<Dead>());
            //historyQuery      = GetEntityQuery(typeof(DamageHistory));
        }

        /*
        /// <summary>
        /// Record a history of all damage events that occured.
        /// </summary>
        [BurstCompile]
        private struct HistoryJob : IJobChunk
        {
            [ReadOnly] public float                    Time;
            [ReadOnly][DeallocateOnJobCompletion] public NativeArray<DamageEvent> DamageEvents;
            [ReadOnly] public ArchetypeChunkEntityType EntityType;

            public ArchetypeChunkBufferType<DamageHistory> DamageHistoryType;

            public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)
            {
                var chunkEntity    = chunk.GetNativeArray(EntityType);
                var chunkHistories = chunk.GetBufferAccessor(DamageHistoryType);

                for (int index = 0; index < chunkEntity.Length; index++)
                {
                    var entity  = chunkEntity[index];
                    var history = chunkHistories[index];

                    for (var i = 0; i < DamageEvents.Length; i++)
                    {
                        if (entity.Equals(DamageEvents[i].Receiver))
                        {
                            var de = DamageEvents[i];

                            var dh = new DamageHistory
                            {
                                TimeOccured     = Time,
                                TookDamage      = true,
                                Damage          = de.Amount,
                                Instigator      = de.Sender,
                                LastDamageEvent = de
                            };

                            history.Add(dh);
                        }
                    }
                }
            }
        }
        */

        /// <summary>
        /// Adds the damage events to a buffer, and then destroys them. They get processed in the following job.
        /// </summary>
        [BurstCompile]
        private struct AddDamageToBufferChunkJob : IJobChunk
        {
            public EntityCommandBuffer.ParallelWriter CommandBuffer;
            [ReadOnly] public EntityTypeHandle EntityType;
            [ReadOnly] public ComponentTypeHandle<DamageEvent> DamageEventType;
            [NativeDisableParallelForRestriction] public BufferFromEntity<HealthBuffer> HealthBufferBuffer; // if the job is scheduled via single NativeDisableParallelForRestriction might not be needed?
            
            public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)
            {
                var entities = chunk.GetNativeArray(EntityType);
                var damageEvents = chunk.GetNativeArray(DamageEventType);
                
                for (int i = 0; i < entities.Length; i++)
                {
                    var entity = entities[i];
                    var damageEvent = damageEvents[i];
                    
                    TryAddToBuffer(damageEvent);
                    
                    // Destroy damage event entity
                    CommandBuffer.DestroyEntity(chunkIndex, entity);
                }
            }

            private void TryAddToBuffer(DamageEvent damageEvent)
            {
                if (HealthBufferBuffer.HasComponent(damageEvent.Receiver))
                    HealthBufferBuffer[damageEvent.Receiver].Add(damageEvent);
            }
        }
        /*
        /// <summary>
        /// Adds the damage events to a buffer, and then destroys them. They get processed in the following job.
        /// </summary>
        [BurstCompile]
        //[ExcludeComponent(typeof(Dead))] // this is actually not needed and a mistake afaik
        private struct AddDamageToBufferJob : IJobForEachWithEntity<DamageEvent>
        {
            public EntityCommandBuffer.Concurrent EntityCommandBuffer;
            [NativeDisableParallelForRestriction] public BufferFromEntity<HealthBuffer> HealthBufferBuffer;
            
            public void Execute(Entity entity, int index, ref  DamageEvent damageEvent)
            {
                if (HealthBufferBuffer.Exists(damageEvent.Receiver))
                {
                    HealthBufferBuffer[damageEvent.Receiver].Add(damageEvent);
                }
                // Destroy damage event entity
                EntityCommandBuffer.DestroyEntity(index, entity);
            }
        }*/
        
        /// <summary>
        /// Applies the damage to the health component. Todo: merge damage and apply in one go? so can be gibbed?
        /// </summary>
        [BurstCompile]
        private struct ApplyDamageChunk : IJobChunk
        {
            public ComponentTypeHandle<Health> HealthType;
            public BufferTypeHandle<HealthBuffer> HealthBufferType;
            public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)
            {
                var healths = chunk.GetNativeArray(HealthType);
                var healthbuffers = chunk.GetBufferAccessor(HealthBufferType);
                for (int i = 0; i < healths.Length; i++)
                {
                    var health = healths[i];
                    var buffer = healthbuffers[i];
                    
                    ApplyBufferToHealth(ref health, buffer);
                    
                    healths[i] = health;
                }
            }

            private void ApplyBufferToHealth(ref Health health, DynamicBuffer<HealthBuffer> buffer)
            {
                if(buffer.Length<1)
                    return;
                
                var damagetotal = new DamageEvent();
                var sender      = Entity.Null;
                
                // Apply damage
                for (var de = 0; de < buffer.Length; de++)
                {
                    sender             =  buffer[de].Value.Sender;
                    damagetotal.Amount += buffer[de].Value.Amount;
                }
                
                health.ApplyDamage(damagetotal);
                health.Damager     = sender;
                health.DamageTaken = damagetotal.Amount;
                buffer.Clear();
            }
        }
        
        /*
        /// <summary>
        /// Applies the damage to the health component. Todo: merge damage and apply in one go? so can be gibbed?
        /// </summary>
        [BurstCompile]
        [ExcludeComponent(typeof(Dead))]
        private struct ApplyDamageJob : IJobForEachWithEntity_EBC<HealthBuffer, Health>
        {
            public void Execute(Entity entity, int index, DynamicBuffer<HealthBuffer> stacks, ref Health health)
            {
                if(stacks.Length<1)
                    return;
                
                var damagetotal = new DamageEvent();
                var sender = Entity.Null;
                
                // Apply damage
                for (var de = 0; de < stacks.Length; de++)
                {
                    sender = stacks[de].Value.Sender;
                    damagetotal.Amount += stacks[de].Value.Amount;
                }
                
                health.ApplyDamage(damagetotal);
                health.Damager = sender;
                health.DamageTaken = damagetotal.Amount;
                stacks.Clear();
            }
        }*/
        
        protected override void OnUpdate()
        {
            /*
            Profiler.BeginSample("Health History");
            var entityType        = GetArchetypeChunkEntityType();
            var damagehistoryType = GetArchetypeChunkBufferType<DamageHistory>();
            
            var historyJob = new HistoryJob
            {
                Time              = (float)Time.ElapsedTime,
                DamageEvents      = damageEventsQuery.ToComponentDataArray<DamageEvent>(Allocator.TempJob),
                EntityType        = entityType,
                DamageHistoryType = damagehistoryType
            };
            var historyHandle = historyJob.Schedule(historyQuery, inputDeps);
            Profiler.EndSample();*/

            Profiler.BeginSample("Health AddToHealthBuffer");
            Dependency = new AddDamageToBufferChunkJob
            {
                CommandBuffer      = endSimulationEntityCommandBufferSystem.CreateCommandBuffer().AsParallelWriter(),
                EntityType         = GetEntityTypeHandle(),
                DamageEventType    = GetComponentTypeHandle<DamageEvent>(true),
                HealthBufferBuffer = GetBufferFromEntity<HealthBuffer>(false)
            }.ScheduleSingle(damageEventsQuery, Dependency);
            endSimulationEntityCommandBufferSystem.AddJobHandleForProducer(Dependency);
            Profiler.EndSample();
            /* // old IJFE
            Dependency = new AddDamageToBufferJob
            {
                EntityCommandBuffer = endSimulationEntityCommandBufferSystem.CreateCommandBuffer().ToConcurrent(),
                HealthBufferBuffer = GetBufferFromEntity<HealthBuffer>()
            }.Schedule(this, Dependency);
            endSimulationEntityCommandBufferSystem.AddJobHandleForProducer(Dependency);
            */
            
            
            Profiler.BeginSample("Health ApplyDamageJob");

            Dependency = new ApplyDamageChunk
            {
                HealthType       = GetComponentTypeHandle<Health>(false),
                HealthBufferType = GetBufferTypeHandle<HealthBuffer>(false)
            }.ScheduleSingle(healthQuery, Dependency);
            
            /*Dependency = new ApplyDamageJob().Schedule(this, Dependency);*/
            Profiler.EndSample();
            
        }
    }
}